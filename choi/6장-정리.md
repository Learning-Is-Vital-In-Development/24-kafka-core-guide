# 6장 - 카프카 내부 메커니즘

## 클러스터 멤버십

- 각 브로커는 브로커 설정 파일에 정의되었거나 자동으로 생성된 고유한 식별자를 가진다.
- 브로커 프로세스는 시작될 때 주키퍼에 Ephemeral 노드의 형태로 ID를 등록하고, 카프카 브로커들과 몇몇 생태계 툴들은 해당 ID가 저장된 /brokers/ids를 구독하여 이벤트를 받는다.
- 브로커와 주키퍼 간의 연결이 끊어질 경우, 주키퍼는 Ephemeral 노드를 자동으로 삭제하고(ID는 삭제 안 됨), 이 이벤트를 다른 카프카 브로커들이 받는다.
- 브로커가 정지하면 ZNode는 사라지지만, 브로커의 ID는 다른 자료구조에 남기에 동일한 ID를 가진 새로운 브로커가 투입되면 클러스터에서 유실된 브로커의 자리를 대신해서 이전 브로커의 토픽과 파티션들을 할당받는다

## 컨트롤러

- **컨트롤러**: 일반적인 카프카 브로커의 기능 + 파티션 리더를 선출하는 역할
- **컨트롤러 생성**: 브로커 시작 → 주키퍼의 /controller에 Ephemeral 노드 생성 → 컨트롤러가 됨
- 브로커들은 주키퍼의 컨트롤러 노드에 변경이 생길 때 알림을 받기 위해 **`와치`**를 설정한다.
    - Ephemeral 노드가 삭제될 경우, 다른 노드들은 와치를 통해 이벤트를 받고, 주키퍼에 컨트롤러 노드를 생성하려고 시도 → 가장 먼저 성공한 브로커가 다음 컨트롤러가 되며, 주키퍼의 conditional increment 연산에 의해 증가된 에포크 값을 다른 노드에 전달하게 된다.
- **컨트롤러 좀비**: 컨트롤러가 GC 도중 다른 노드가 컨트롤러로 선출된 경우, GC가 끝난 노드가 이 사실을 알지 못하고 브로커에 메시지를 보낼 경우를 뜻한다.
    - 컨트롤러가 전송하는 메시지에 컨트롤러 **`에포크`**를 포함하기에 브로커는 예전 컨트롤러가 보내온 메시지를 무시할 수 있다.(더 낮은 에포크값을 가진 컨트롤러부터 받은 메시지를 무시하기 때문)
- 브로커가 컨트롤러로 되면 클러스터 메타데이터 관리 및 리더 선출 시작 전에 주키퍼로부터 최신 레플리카 상태 맵을 읽어옴
- 컨트롤러는 브로커가 클러스터를 나가면 해당 브로커가 리더를 맡고 있었던 모든 파티션에 대해 새로운 브로커를 할당한다.

## KRaft

- raft 기반 컨트롤러로 기존 컨트롤러의 확장성 이슈를 해결하기 위해 등장
- 중요한 두 가지 기능
    - 컨트롤러 선출
    - 클러스터 메타데이터(현재 운영중인 브로커, 설정, 토픽, 파티션, 레플리카 관련 정보) 저장
- 컨트롤러 설계의 핵심 아이디어: 카프카 그 자체에 사용자가 상태를 이벤트 스트림으로 나타낼 수 있도록 하는 로그 기반 아키텍처 도입
    - 컨트롤러 노드들은 메타데이터 이벤트를 관리하는 래프트 쿼럼이 된다.(메타데이터 변경 내역 저장)
    - 래프트 알고리즘을 통해 컨트롤러가 외부 시스템의 의존 없이 자체적으로 리더를 선출할 수 있게 됨
    - 래프트 알고리즘은 리더와 팔로워 노드 간의 합의를 통해 메타데이터의 일관성을 보장한다.(메타데이터는 Raft 합의 알고리즘을 통해 분산 복제됨)
    - 메타데이터 로그의 리더 역할을 맡은 컨트롤러: 액티브 컨트롤러

## 복제

<aside>
✨ 카프카에 저장되는 데이터는 토픽 단위로 조직화되고, 각 토픽은 1개 이상의 파티션으로 분할되며, 각 파티션은 다수의 레플리카를 가진다.

</aside>

- 리더 레플리카
    - 일관성 보장을 위해 모든 쓰기 요청은 리더 레플리카로 주어진다.
- 팔로워 레플리카
    - 리더 레플리카로 들어온 최근 메시지를 복제한다.
    - 해당 파티션의 리더 레플리카에 크래쉬가 날 경우, 팔로워 레플리카 중 하나가 파티션의 새 리더 파티션으로 승격된다.
    - 별도의 설정 없인 클라이언트의 요청을 처리할 수 없다.
- 팔로워 레플리카는 리더 레플리카와의 동기화를 위해 읽기 요청을 보낸다.(컨슈머가 브로커에게 보내는 요청과 동일하다)
- 리더에 장애가 난 경우 in-sync 레플리카에만 요청을 보낼 수 있다.

## 요청 처리

<aside>
✨ 카프카 브로커가 하는 일의 대부분은 클라이언트, 파티션 레플리카, 컨트롤러가 파티션 리더에게 보내는 요청을 처리하는것

</aside>

- 요청 처리 순서도
    - acceptor 스레드가 요청을 받아 네트워크 스레드에 넘김 → 네트워크 스레드가 요청을 요청 큐에 넣고, 지연된 응답들이 완료될 때까지 퍼거토리에 저장 → 응답 큐에서 응답을 가져다 클라이언트 반환
    - I/O 스레드는 요청 큐에서 요청을 가져와 처리하고 응답 큐에 넣는다.
- 쓰기 요청
    - acks를 1, all, 0으로 두는지에 따라 메시지에 대한 응답 타이밍이 달라진다.
- 읽기 요청
    - 클라이언트는 각 파티션에 대해 브로커가 리턴할 수 있는 최대 데이터의 양 + 최소 데이터 양을 지정해야 한다.
    - 클라이언트는 읽기 요청을 정확히 라우팅할 수 있도록 필요한 메타데이터에 대한 요청을 보내게 된다.
    - 카프카는 **`제로 카피`** 최적화 기법을 적용하여 파일에서 읽어온 메시지들을 중간 버퍼를 거치지 않고 바로 네트워크 채널로 보내어 성능 향상을 이루었다.
    - 특정 메시지가 모든 in-sync 레플리카에 쓰여지기 전까지는 컨슈머들이 읽을 수 없다.

## 물리적 저장소

- **계층화된 저장소**
    - 데이터를 여러 계층으로 분리하여 저장하는 방식을 의미
    - 이 접근 방식은 주로 성능과 비용 효율성을 최적화하기 위해 사용됨
    - **핫 스토리지**: 최근 데이터는 빠른 접근이 가능한 고성능 스토리지에 저장(SSD나 메모리를 사용)
    - **콜드 스토리지**: 오래된 데이터는 저비용 스토리지로 이동 (HDD나 클라우드 스토리지 서비스를 사용)
    - **데이터 이동**: 데이터는 주기적으로 핫 스토리지에서 콜드 스토리지로 이동하며, 이는 정책에 따라 자동으로 관리
- **파티션 할당**
    - Kafka 토픽은 여러 파티션으로 나뉘며, 각 파티션은 클러스터 내의 브로커에 분배
    - **균등 분배**: Kafka는 파티션을 브로커 간에 균등하게 분배하여 부하를 고르게 분산
    - **재할당**: 브로커가 추가되거나 제거되면, 파티션 재할당이 이루어져 새로운 균형 상태를 유지
- **파일 관리**
    - Kafka는 각 파티션을 물리적으로 여러 세그먼트 파일로 나누어 저장
    - **세그먼트 파일**: 각 파티션은 여러 세그먼트 파일로 나뉜다. 세그먼트 파일은 고정된 크기로 나누어지며, 데이터는 순차적으로 기록된다.
    - **로그 세그먼트**: 새 데이터는 현재 활성 세그먼트 파일에 기록되며, 활성 세그먼트 파일이 가득 차면 새로운 세그먼트 파일이 생성된다.
    - **파일 회전**: 오래된 세그먼트 파일은 주기적으로 삭제되거나 콜드 스토리지로 이동
- **파일 형식**
    - Kafka의 데이터 파일 형식은 효율적인 저장과 빠른 접근을 목표로 설계됨
    - **로그 포맷**: 각 로그 항목은 오프셋, 타임스탬프, 키, 값, 체크섬으로 구성
    - **바이너리 포맷**: 데이터는 바이너리 형식으로 저장되어 저장 공간을 절약하고 I/O 성능을 향상
- **인덱스**
    - **오프셋 인덱스**: 각 세그먼트 파일에 대해 오프셋 인덱스가 생성되어 특정 오프셋의 데이터를 빠르게 찾을 수 있도록 도와준다.
    - **타임스탬프 인덱스**: 타임스탬프를 기반으로 데이터를 검색할 수 있도록 타임스탬프 인덱스도 사용된다.
    - **인덱스 파일**: 인덱스는 별도의 파일에 저장되며, 주기적으로 업데이트된다.
- **압착**
    - 특정 키의 최신 기록만 유지하도록 불필요한 오래된 로그 항목을 제거
    - **작동 원리**: 압착은 로그 세그먼트 파일을 스캔하여 동일한 키의 최신 값만 남기고 이전 값을 제거
    - **압착 주기**: 압착은 주기적으로 또는 특정 조건이 충족될 때 실행된다.
