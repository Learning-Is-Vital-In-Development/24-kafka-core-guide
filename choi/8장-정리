# 8장 - ‘정확히 한 번’ 의미 구조

> 동일한 작업을 여러 번 실행해도 한 번 실행한 것과 결과가 같은 서비스를 **`멱등적`**이라고 한다.
> 

## 멱등적 프로듀서

<aside>
✨ 고유한 식별자를 통해 멱등성을 보장하지만, 프로듀서 자체의 재시도 매커니즘(프로듀서, 네트워크, 브로커 에러로 인해 발생하는)에 의한 중복만 방지할 뿐, 그 이상은 하지 않는다.
(동일한 메시지로 producer.send()를 두 번 호출할 때 발생하는 중복 메시지는 막을 수 없다.)

</aside>

- **식별자**: 대상 토픽 및 파티션 + producer id, sequence id
- 멱등적 프로듀서 기능을 켜면 모든 메시지는 고유한 프로듀서 ID와 시퀀스 넘버를 가지게 된다.
- 각 브로커는 해당 브로커에 할당된 모든 파티션들에 쓰여진 마지막 5개 메시지들을 추적하기 위해 이 고유 식별자를 사용한다.

## 트랜잭션

- 카프카 트랜잭션은 원자적 다수 파티션 쓰기 기능을 통해 읽어 온 원본 메시지의 오프셋이 커밋되고 결과가 성공적으로 쓰여지거나, 둘 다 안 일어나거나를 보장한다.
- 결과를 출력 토픽에, 오프셋을 _consumer_offsets 토픽에 써서 둘 다 성공하면 커밋할 수 있다.
- 트랜잭션을 사용해서 원자적 다수 파티션 쓰기를 수행하려면 **`트랜잭션적 프로듀서`**를 사용해야 한다.

**트랜잭션적 프로듀서와 일반 프로듀서의 차이점**

- [transactional.id](http://transactional.id)를 갖고 있어 카프카 브로커는 transactional.id와 [producer.id](http://producer.id)로의 대응관계를 유지하고 있다가 만약 이미 있는 transactional.id 프로듀서가 initTransactions()를 다시 호출하면 새로운 랜덤값이 아닌 이전에 쓰던 producer.id 값을 할당해준다.

**좀비 펜싱**

- 애플리케이션의 좀비 인스턴스가 중복 프로듀서를 생성하는 것을 방지하려면 좀비 펜싱, 혹은 애플리케이션의 좀비 인스턴스가 출력 스트림에 결과를 쓰는 것을 방지할 필요가 있다.
- 카프카는 트랜잭션적 프로듀서가 초기화를 위해 initTransaction()를 호출하면 transaction.id에 해당하는 **`에포크`** 값을 증가시켜 에포크 값이 낮은 프로듀서로의 요청에 대해 에러를 발생시키며 거부할 수 있다.

**isolation.level 설정**

- read_uncommited(default): 진행중이거나 중단된 트랜잭션에 속하는 것들을 포함한 모든 레코드가 리턴
- read_commited: 커밋된 트랜잭션에 속한 메시지나 처음부터 트랜잭션에 속하지 않은 메시지만 리턴
- 메시지의 읽기 순서를 보장하기 위해 read_commited 모드에서는 아직 진행중인 트랜잭션이 처음으로 시작된 시점(Last Stable Offset, LSO) 이후에 쓰여진 메시지는 리턴되지 않는다.

### 트랜잭션이 해결할 수 없는 문제들

1. 스트림 처리에 있어서의 부수 효과: 스트림 처리 애플리케이션의 처리 단계에서 사용자 이메일을 보내는 작업은 정확히 한 번 의미 구조를 활성화한다고 해서 이메일이 한 번 발송되는 것은 아니다.(카프카에 쓰여지는 레코드에 대해서만 보장하기 때문)
2. 카프카 토픽에서 읽어서 데이터베이스에 쓰는 경우: 하나의 트랜잭션에서 외부 데이터베이스에는 결과를 쓰고, 카프카에는 오프셋을 커밋할 수 있도록 해주는 메커니즘은 없다.
    1. 마이크로서비스에서 하나의 원자적 트랜잭션 안에서 db 업데이트 및 카프카에 메시지도 써야 하는 경우, 카프카 트랜잭션으로는 원자성이 보장되지 않는다. 일반적인 해법은 아웃박스 패턴을 통해 원자성을 보장한다. 마이크로서비스는 아웃박스라고 불리는 카프카 토픽에 메시지를 쓰는 작업까지만 하고, 별도의 메시지 중계 서비스가 카프카로부터 메시지를 읽어와서 데이터베이스를 업데이트한다.
3. 데이터베이스에서 읽어서, 카프카에 쓰고, 여기서 다시 다른 데이터베이스에 쓰는 경우
4. 한 클러스터에서 다른 클러스터로 데이터 복제
5. 발행/구독 패턴
