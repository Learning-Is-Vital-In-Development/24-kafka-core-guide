# 13장 카프카 모니터링하기

## 13.1 지표 기초

### 13.1.1 지표는 어디에 있는가?

- 비애플리케이션 지표
    1. 애플리케이션 지표 : 카츠카 자체의 JMX 인터페이스에서 나온 지표
    2. 로그 : 카프카 자체에서 나온 또 다른 타입의 모니터링 데이터. 숫자가 아니라 텍스트 내지 구조화된 데이터이기 때문에 추가 처리를 좀 더 해야 함 
    3. 인프라스트럭처 지표 : 카프카의 앞단, 요청이 들어오는 길목에 설치되어 있으며 재가 제어할 수 있는 시스템에서 발생하는 지표(ex 로드 밸런스) 
    4. 특수 클라이언트 지표 : 카프카 외부의 툴에서 나온 데이터. 일단은 클라이언트 지표지만, 직접적으로 제어가 가능하며 외부 모니터링 툴임
    5. 일반 클라이언트 지표 : 카프카 클러스터에 접속한 카프카 클라이언트로부터 나온 지표

### 13.1.2 어떤 지표가 필요한가?

어느 지표가 가장 중요하느냐의 어느 에디터가 가장 좋은 것이냐와 같은 논란의 질문

용도에 따라 달라짐

1. 경보냐 디버깅이냐
    - 경보의 경우 : 문제에 대응하는데 걸리는 시간보다 그리 길지 않은 경우에 유용하며 몇시간이나 며칠 정도 측정할 수 있음
    - 디버깅의 경우 : 일정 시간동안 존재하는 문제의 원인을 자주 진단해야 안다거나 복잡한 문제여서 깊이 들여다 봐야 할 경우 유용하며 며칠 혹은 몇주가 지난 뒤에도 사용 가능해야 함
2. 자동화가 목적인지, 사람이 볼 것인지
    - 자동화를 목적으로 하는 경우 : 대량의 메트릭을 사용해서 아주 세세한 부분까지 대량의 데이터를 수집해도 상관없음
    - 사람이 봐야 하는 경우 : 대량으로 수집하면 오히려 압사 당하며 경보 피로감에 빠지기 쉽고 문턱 값을 적절히 정의하고 항상 최신으로 유지하는 것 역시 쉽지 않음

### 13.1.3 애플리케이션 상태 검사

- 브로커가 살아 있는지의 여부를 알려주는 외부 프로세스를 사용(상타 검사)
- (만료 된 지표) 카프카 브로커에서 들어와야 하는 지표가 들어오지 않을 떄 경보

## 13.2 서비스 수준 목표

### 13.2.1 서비스 수준 정의

- 서비스 수준 지표(SLI) : 2xx, 3xx, 4xx 응답을 받은 요청의 비율
- 서비스 수준 목표(SLT) : “7일간 웹 서버에 대한 요청 중 99%가 2xx, 3xx, 4xx 응답을 받아야 한다”와 같은 목표값을 결합한 것
- 서비스 수준 협약(SLA)=서비스 수준 목표(SLO) : “만약 서비스 제공자가 SLO 수준의 작동을 제공하지 못할 경우 해당 기간에 대한 모든 비용을 환불해준다”는 식의 제공자와 클라이언트 사이의 계약

### 13.2.2 좋은 서비스 수준 지표를 위해서는 어떠한 지푯값을 써야 하는가?

- SLI에 연관된 지표는 카프카 브로커 외부에 있는 어딘가에서 수집되어야 함
- SLO는 사용자의 만족 여불르 가리켜야 하고, 주관적인 것인 만큼 측정할 수 없음
    - 클라이언트는 운영자이 생각이 중요하지 않고 사용자 입장에서의 전체적인 경험이 중요

- SLI의 종류
    1. 지연 : 응답이 얼마나 빨리 리턴되는가?
    2. 질 : 응답의 내용이 적절한가?
    3. 보안 : 요청과 응답이 적절히 보호되는가? 권한이나 암호화 측면에서도?
    4. 처리량 : 클라이언트가 충분한 속도로 데이터를 받을 수 있는가?

### 13.2.3 경보에 SLO를 사용하기

- SLO는 주된 경보로 설정되어 있어야 함
- 사용자 관점에서 문제를 기술하는 것이고, 운영자 입장에서 가장 먼저 고려해야 함
- 예전에 경험 한적도 없고 찾아내는 방법도 모르는 문제를 알려주는 역할을 함
- 무엇이 문제인지는 알려주지 않지만 문제가 있다는 것을 알려 줌
- 1주일 정도의 수집을 하는게 좋음
- 가장 좋은 방법은 소진율을 보는 것임

## 13.3 카프카 브로커 지표

@ 감시자는 누가 감시하는가?

- 중앙 모니터링 시스템에서 사용할 애플리케이션 지표, 시스템 지표, 로그를 저장하는 데 카프카를 사용
- 애플리케이션과 모니터링 시스템을 분리하는 좋은 방법

### 13.3.1 클러스터 문제 진단하기

- 단일 브로커에서 발생하는 문제
    - 대체로 고장난 저장 장치나 시스템 내의 다른 애플리케이션으로 인한 자원 제한으로 인해 발생
    - 하드웨어나 운영체제 수준에서 발생하는 경우는 카프카 클러스터 안에서 요청이 몰려서 발생함
        - 외부 툴 중 크루즈 콘트롤 : 클러스터를 계속 모니터링 하다가 파티션을 리밸런싱 함
- 과적재된 클러스터에서 발생하는 문제
    - 다 수의 브로커가 요청에 대해 높은 지연을 가지거나 요청 핸들러 풀의 유휴 비율이 높다면, 브로커가 처리할 수 있는 트래픽의 한계에 다다른 것임
    - 클러스터에 걸리는 부하를 줄이던지, 브로커 수를 늘리던지 둘 중 하나로 대응
- 컨트롤러 문제
    - 카프카 그 자체의 버그인 경우도 많음
    - 브로커 메타 데이터 동기화가 끊어진다거나 레플리카는 오프라인 상태이거나 토픽 생성과 같은 기능이 제대로 동작하지 않는 다든가 함
    - “이거 참 이상하네” 하는 경우는 컨트롤러가 오작동해서 생기는 문제가 많음
    - 활성 컨트롤러 수나 컨트롤러 큐 크기와 같은 지표를 모니터링함으로써 문제 발생을 알아차릴 수 있음

### 13.3.2 불완전 복제 파티션 다루기

- 클러스터에 속한 브로커 단위로 집계
- 해당 브로커가 리더 레플리카를 잡고 있는 파티션 중 팔로워 레플리카가 따라오지 못하고 있는 파티션의 수
- 다수의 브로커가 일정한 수의 불완전 복제 파티션을 가지고 있다는 것은 보통 클러스터의 브로커 중 하나가 내려가 있다는 것을 의미
- 전체 클러스터에 걸친 불완전 복제 파티션 수는 내려간 브로커에 할당된 파티션의 수 와 같음
- 케이스
    - 불완전 복제 파티션의 수가 오르락내리락 하거나, 수는 일정한데 내려간 브로커가 없다면 대개 클러스터의 성능 문제
        - 단일 브로커에 국한 된것인지 아니면 클러스터 전체에 연관된 것인지 확인 필요
    - 어느 브로커가 문제인지 찾아내야 하는 경우의 한 가지 방법
        - 클러스터 내 불완전 복제 파티션의 목록을 뽑은 뒤 공통되는 브로커가 있는지 확인

1. 클러스터 수준 문제
    - 부하 불균형 : 찾기 쉽지만 해결하는건 복잡함
        - 파티션의 수
        - 리더 파티션의 수
        - 전 토픽에 있어서의 초당 들어오는 메시지
        - 전 토픽에 있어서의 초당 들어오는 바이트
        - 전 토픽에 있어서의 초당 나가는 바이트
    - 자원 고갈
        - CPU 사용률
        - 인바운드 네트워크 속도
        - 아웃바운드 네트워크 속도
        - 평균 디스크 대시 시간
        - 디스크 평균 활용률
        
        → 만약 하나라도 고갈되면 불완전 복제 파티션 발생
        
2. 호스트 수준 문제
    - 하드웨어 장애
    - 네트워킹
    - 다른 프로세스와의 충돌
    - 로컬 구성의 차이

### 13.3.3 브로커 지표

1. 활성 컨트롤러 수 : 임의의 클러스터에는 언제나 딱 하나의 컨트롤러가 있어야 함
2. 컨트롤러 큐 크기 : 현재 컨트롤러에서 브로커의 처리를 기다리고 있는 요청의 수 
3. 요청 핸들러 유휴 비율 : 네트워크 스레드 풀과 요청 핸들러 스레드 풀 두 개의 풀 사용
    - 요청 핸들러가 작동 중이지 않은 시간 비율(%)을 가르킴
    - 낮을수록 브로커에 부하가 많이 걸려 있음
    - 경험적으로 20% 이하는 잠재적 문제 있고 10%이하는 성능 문제가 진행형임
    - 클러스터 크기가 너무 작은 것 외에도 요청 핸들러 스레드 풀의 사용률이 높아지는데는 두 가지
        1. 스레드 수가 충분하지 않은 경우
            - 요청 핸들러 스레드의 수 = 시스템의 프로세서 수
        2. 스레드들이 요청별로 쓸데 없는 작업을 할 경우 
4. 전 토픽 바이트 인입
    - 속도는 브로커가 프로듀서 클라이언트로부터 얼마나 많은 메시지 트래픽을 받는지에 대한 측정값으로서 유용
    - 변화 추이를 보면서 언제 클러스터를 확장해야 하는지, 트래픽이 어떻게 증가함에 따라 필요한 다른 작업을 언제 해야 하는지 결정에 유용
    - 속도 지표 7가지
        1. EventType : 모든 지표의 단위(바이트)
        2. RateUnit : 속도 지표의 시간적 기준(초)
        - 서로 다른 시간 간격에 대해 산출 되는 속성 4가지
            1. OneMinuteRate : 지난 1분간의 평균 
            → 빠르게 변할 뿐 아니라 측정값에 대해 ‘특정 시점’ 이상의 관점을 보여줌
            2. FiveMinuteRate : 지난 5분간의 평균
            3. FifteenMinuteRate : 지난 15분간의 평균
            4.  MeanRate : 브로커가 시작된 이후의 평균
            → 잘 변하지 않으며, 전체적인 추세를 보여줌
        - Count 속성 : 브로커가 시작된 시점부터 지속적으로 증가하는 값
5. 전 토픽 바이트 유출
    - 전 토픽 유출 속도 : 트래픽의 전체적인 성장세를 보여주는 또 달느 지표
    - 컨슈머가 메시지를 읽는 속도를 보여줌
    
    @ 레플리카 트래픽 포함
    
    유출 바이트 속도는 레플리카에 의해 발생하는 트래픽 포함 
    
    모든 토픽의 복제 팩터가 2라면 데이터를 읽어가는 컨슈머 클라이언트가 없더라도 인입 속도와 유출 속도가 똑같음
    
    클러스터의 모든 메시지를 읽는 컨슈머 클라이언트가 하나 붙는다면 유출 속도는 인입 속도의 딱 두배가 됨
    

1. 전 토픽 메시지 인입
    - 메세지 인입 속도는 메시지 크기와 무관하게 초당 들어오는 메시지 수
    - 트래픽 성장을 보여주는 지표
2. 파티션 수
    - 한 브로커의 파티션 전체 개수는 대체로 그리 자주 변하지 않고 브로커에 할당된 파티션의 전체 개수임
3. 리더 수 
    - 브로커가 현재 리더를 맡고 있는 파티션의 수를 보여줌
4. 오프라인 파티션 
    
    → 현재 리더가 없는 파티션의 수 
    
    - 레플리카를 보유하고 있는 모든 브로커가 다운되었을 떄
    - (언클린 리더 선출 기능이 꺼져 있는 상태에서) 저장된 메시지 개수가 모자란 탓에 리더 역할을 맡을 수 있는 인-싱크 레플리카가 없을 때
    - ‘사이트 다운’과 같은 문제를 일으키므로 즉시 해결해야 함
5. 요청 지표 
    - 전체 시간 : 브로커에 요청이 수신되어 응답이 전송될 때까지 걸린 전체 시간
    - 요청 큐 시간 : 요청이 수신되어 처리가 시작되기 전까지 큐에서 대기한 시간
    - 로컬 시간 : 파티션 리더가 요청을 처리하는 데 걸린 시간, 디스크에 전달하는 시간 포함
    - 원격 시간 : 요청 처리가 완전히 끝나기 전 팔로워를 기다리는 시간
    - 스로틀 시간 : 클라이언트 쿼터 설정을 만족시키기 위해 응답을 내보내지 않고 붙잡아 놓는 시간
    - 응답 큐 시간 : 요청에 대한 응답이 요청자에게 리턴되기 전 큐에서 대기하는 시간
    - 응답 전송 시간 : 응답 보내는데 소요 된 시간
    
    각 지표에서 제공 되는 속성
    
    - Count : 프로세스가 시작된 후의 요청 개수
    - Min : 전체 요청 중 최저값
    - Max : 전체 요청 중 최대값
    - Mean : 전체 요청의 평균값
    - StdDev : 요청이 들어온 시각에 측정된 측정값의 표준 편차
    - Precentiles : 50Precentile, 75Precentile, 95Precentile, 98Precentile, 99Precentile, 999Precentile
    

## 13.3.4 토픽과 파티션별 지표

1. 토픽별 지표
    - 초당 바이트 인입
    - 초당 바이트 유출
    - 초당 실패한 읽기 요청 개수
    - 초당 인입 메시지 수
    - 초당 읽기 요청 수
    - 초당 쓰기 요청 수
2. 파티션별 지표
    - 파티션 크기
    - 로그 세그먼트 수
    - 로그 끝 오프셋
    - 로그 시작 오프셋

### 13.3.5 JVM 모니터링

1. 가비지 수집
    - CollectionCount : GC 사이클 수
    - CollectionTIme : GC 사이클 소요된 시간(밀리초)
2. 자바 운영체제 모니터링
    - MaxFileSescriptorCount : JVM이 열 수 있는 최대 파일 디스크립터의 수
    - OpenFileDescriptorCount : 현재 열려 있는 FD 수

### 13.3.6 운영체제 모니터링

- CPU 약어
    - us : 사용자 모드에서 사용된 시간
    - sy : 커널 모드에서 사용된 시간
    - ni : 낮은 우선순위의 프로세스에서 사용된 시간
    - id : 유휴 시간
    - wa : 디스크에서의 대기 시간
    - hi : 하드웨어 인터럽트 처리에 사용된 시간
    - si : 소프트웨어 인터럽트에 사용된 시간
    - st : 하이퍼바이저에서의 대기 시간

@ 시스템 부하란

CPU 사용량 측정이 아니라 실행할 수 있지만 실행을 위해 프로세서를 기다리고 있는 프로세스의 수 

CPU가 하나뿐인 시스템에서 이 값이 1이라면 시스템 부하는 100% 언제나 실행 대기중인 스레드가 하나 있다는 의미 

### 13.3.7 로깅

별도의 디스크 파일로 저장하는 로거 2개

1. INFO 레벨로 로깅되는 kafka.controller 로거
2. INFO 레벨로 로깅되는 kafka.server.ClientQuotaManager 로거

## 13.4 클라이언트 모니터링

### 13.4.1 프로듀서 지표

1. 프로듀서 종합 지표
    - 메시지 배치 크기부터 메모리 버퍼 활용에 이르는 모든 것을 나타냄
    - record-error-rate 속성은 반드시 경보 설정
        - 언제나 0이어야 하며 그보다 크다면 프로듀서가 브로커로 메시지를 보내는 와중에 누수가 발생하고 있음 의미
    - 프로듀서는 백오프를 해가면서 사전 설정된 수만큼 재시도 하게 되어 있음
        - 재시도 수가 고갈되면 폐기함
    - request-latency-avg도 경보 설정을 해야함
        - 브로커가 쓰기 요청을 받을 떄까지 걸린 평균 시간
        - 정상 작동 상태에서 기준값을 찾은 뒤 이 기준값보다 큰 값으로 경보 문턱 값을 설정
        - 요청에 대한 지연이 증가하는 것은 쓰기 요청이 점점 느려지고 있음을 의미
    - record-queue-time-avg : 메시지를 전송한 뒤 실제로 카프카에 쓰여지기 전까지 프로듀서에서 대기하는 평균 시간(밀리초)
        - batch.size
        - 마지막 배치가 전송된 이래 linger.ms 설정에 지정된 시간 경과
2. 브로커별, 토픽별 지표

### 13.4.2 컨슈머 지표

- 컨슈머 전체
- 읽기 매니저
- 토픽별
- 브로커별
- 코디네이터

1. 읽기 매니저 지표
    - 바이트, 요청, 레코드에 대한 지표
    - fetch-latency-avg : 경보 설정 권장, 일긱 요청을 보내는데 걸리는 시간
        - fetch.min.bytes
        - fetch.max.wait.ms
    
    @ 랙이 없다고?
    
    records-lag-max 속성을 모니터링 권장 하지 않는 이유
    
    현재 랙, 가장 뒤저진 파티션의 현재 랙, 컨슈머 오프셋과 브로커의 로그 엔드 오프셋 사이의 차이를 보여줌
    
    해당 지표의 문제점 두가지 
    
    1. 단 하나의 파티션에 대한 랙만 보여 줌
    2. 컨슈머가 제대로 작동하고 있을 경우 상정 
    
    컨슈머 클라이언트가 얼마나 많은 메시지 트래픽을 처리중인지를 알려면
    
    1. bytes-consumed-rate
    2. reords-consumed-rate 
2. 브로커별, 토픽별 지표
3. 컨슈머 코디네이터 지표

### 13.4.3 쿼터

- 하나의 클라이언트가 전체 클러스터를 독차지 하는 것을 방지하기 위해 클라이언트 요청을 스로틀링을 하는 기능
- 각 클라이언트 ID에서부터 각 브로커까지 허용된 트래픽(초당 바이트) 형태로 표시
- 모든 클라이언트에 적용되는 기본 값은 브로커 설정에 하지만, 클라이언트별로 동적으로 재정의 가능

## 13.5 랙 모니터링

→ 프로듀서가 특정 파티션에 마지막으로 쓴 메시지와 컨슈머가 마지막으로 읽고 처리한 메시지 사이의 차이 

버로우 툴 : 내 모든 컨슈머 그룹의 랙 정보를 가져온 뒤 각 그룹이 제대로 동작하는지, 뒤쳐지지고 있는지, 일시중지되거나 완전히 중지되었는지를 계산해서 보여줌 

## 13.6 종단 모니터링

지연 증가 원인이 무엇인지 파악

- 클라이언트 탓인지
- 네트워크 탓인지
- 카프카 자체의 문제인지

운영 책임 

- 카프카 클러스터에 메시지를 쓸 수 있는가?
- 카프카 클러스터에서 메시지를 읽어 올 수 있는가?
-
