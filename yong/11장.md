# 11장 보안

카프카는 각각의 활용 사례에 맞는 보안 설정을 지원하기 위해 여러 표준 보안 기술과 함께 다양한 설정 옵션을 지원함

시스템 보안은 딱 가장 약한 고리만큼만 강한 법이고, 보안 절차와 정책 역시 시스템 전체에 걸쳐 적용되어야 한다

## 11.1 보안 설정 적용하기

- 인증은 사용자가 누구인지 식별
- 인가는 사용자가 무엇을 할 수 있는지를 결정
- 암호화는 누설과 위조로부터 데이터를 보호
- 감사는 사용자가 무엇을 했는지, 하려 했는지를 추척
- 쿼터는 자원을 얼마나 많이 사용할 수 있는지를 조절

안전한 카프카 클러스터의 특징

1. 클라이언트 진정성 : 연결을 맺을 때 클라이언트가 맞는지 인증해야함
2. 서버 진정성 : 리더 브로커로 메시지를 보내기 전에, 실제 브로커와 맺어진 것임을 검증해야함
3. 기밀성 : 메시지가 전달되는 도중에 있는 모든 연결은 암호화되거나, 물리적으로 보호되어서 외부에서 내용물을 엿보거나 훔칠 수 없어야 함
4. 무결성 : 안전하지 못한 네트워크를 통해 전송되는 모든 데이터에 메시지 다이제스트를 포함함으로써 내용물 변조시 알아차릴 수 있어야 함
5. 접근 제어 : 메시지를 읽거나 쓰기전에 권한이 있는지 확인해야 함
6. 감사 기능성 : 수행하는 모든 작업을 보여주는 감사용 기록이 남아야 함
7. 가용성 : 대역폭을 혼자 독차지하거나 브로커에 서비스 거부 공격을 가하는 것을 방지하는 쿼터와 제한

## 11.2 보안 프로토콜

카프카 브로커에는 1개 이상의 엔드포인트를 가진 리스너 설정이 있는데, 클라이언트로부터의 연결을 받음

물리적으로 보호되고 인가된 사람만이 접근 가능한 내부 리스너의 보안 요구 조건은 공용 인터넷을 통해 접근 가능한 외부 리스너와는 다를 수 있다.

보안 프로토콜은 인증과 전송되는 데이터의 암호화 수준을 결정함

카프카는 2개의 표준 기술 TLS(SSL)와 SASL을 사용해 4개의 보안 프로토콜 지원

- PLAINTEXT : 일반 사설 네트워크에서 인증, 암호화가 필요 없는 일반 정보에 적합
- SSL : SSL 전송 계층은 선택적으로 클라이언트 SSL 인증 수행으로 안전하지 않은 네트워크에 적합
- SASL_PLAINTEXT : SASL 인증 방식으로 사설 네트워크에 적합
- SASL_SSL : 안전하지 않은 네트워크에 적합

@ 팁 : SASL? SSL?

둘 중 어느게 더 좋은지는 용도에 따라 다름

SSL : 공개 키 암호화를 사용한 통신 프로토콜 - 종단 사이에 교환되는 메시지를 안전하게 보호를 목표

SASL : 종단 간에 사용할 인증 방식을 서로 합의할 수 있도록 해주는 프레임워크 

## 11.3 인증

서버와 클라이언트간의 서로의 신원을 확인하는 과정

### 11.3.1 SSL

1. TLS 설정하기
2. 고려사항

### 11.3.2 SASL

- GSSAPI : 케르베로스 인증 지원, 케르베르스 서버와 통합에 사용
- PLAIN : 사용자 이름/비밀번호 인증, 외부 저장소를 이용해 서버측 커스텀 콜백 함께 사용
- SCRAM-SHA-256 and SCRAM-SHA-512 : 사용자 이름/비밀번호
- OAUTHBEARER : Oauth bearer 토큰 방식

1. SASL/GSSAPI
케르베르스 : 널리 사용되고 있는 프로토콜, 불안전한 네트워크에서 안전한 상호 인증을 구한하기 위해 강력한 암화화 기능 이용
→ 서로 다른 인증 매커니즘을 사용하는 애플리케이션에 보안 서비스를 제공하기 위해 개발 된 프레임워크
2. SASL/PLAIN
RFC-4616 : 안전한 인증을 위해 TLS와 함께 사용될 수 있는 단순한 사용자 이름/비밀번호 인증 메커니즘
→ 클라이언트 인증 과정에서 사용자 이름/비밀번호 서버에 전송하고 서버는 저장소에 저장된 비밀번호 값을 검증
3. SASL/SCRAM
RFC-5802 : SASL/PLAIN처럼 비밀번호를 직접 전송하는 메커니즘에서 보안 문제를 대처할 수 있는 안전한 사용자 이름/비밀번호 인증 메커니즘을 제안
→ 암호화 되지 않은 비밀번호 전송을 피하고 악의적인 사용자가 다른 사용자로 가장해서 내용을 읽을 수 없도록 저장
4. SASL/OAUTHBEARER
RFC-7628(Oauth) : 애플리케이션이 HTTP 서비스에 대해 제한된 접근 권한을 흭득할 수 있도록 해주는 인가 프레임워크
→ 베어러 토큰을 사용하되 더 짧은 토큰 유효기간과 제한된 자원 접근만 허용
5. 위임 토큰
카프카 브로커가 클라이언트 사이에 공유된 비밀로서 클라이언트에 SSL 키스토어나 케르베르스 키탭 파일을 배포할 필요 없는 경량 설정 메커니즘을 제공
→ 카프카 커넥트와 같은 프레임워크는 워커에 대한 보안 설정을 단순화하기 위해 위임토큰을 사용할 수 있음

### 11.3.3 재인증

카프카 브로커는 클라이언트가 새로운 연결을 맺는 시점에서 클라이언트 인증 수행

브로커가 클라이언트의 자격 증명을 검증해서 해당 시점에 유효할 경우 연결에 대한 인증이 성공함

케르베리스나 OAuth와 같은 보안 메커니즘은 유효기간이 있는 자격 증명 사용

- 유효기간이 있는 자격 증명을 사용하도록 되어 있는 GSSAPI나 OAUTHBEARER와 같은 SASL 메커니즘에서 재인증 기능은 현재 작동 중인 연결이 유효한 자격 증명을 사용해서 인증되었음을 보장
- 단기간만 사용이 가능한 자격 증명을 사용하면 자격 증명이 위조되는 경우에도 시스템이 위험에 노출되는 시간을 줄일 수 있음
- PLAIN이나 SCRAM과 같은 비밀번호 기반 SASL 메커니즘은 주기적인 로그인을 설정함으로써 암호 순환 기능을 지원
- connections.max.reauth.ms : 짧은 유효기간이 없는 자격 증명을 포함한 모든 SASL 메커니즘에 대해 재인증 요구, 이미 폐기된 자격 증명과 결부된 연결이 작동하는 시간을 줄여줌
- SASL 재인증 기능이 설정되지 않으면 클라이언트로부터 연결은 세션이 종결되면서 끊어짐

### 11.3.4 무중단 보안 업데이트

비밀번호를 순환시키거나, 보안 패이를 적용하거나, 최신 보안 프로토콜을 업데이트하거나 하기 위해서는 정기적으로 카프카를 정비해야함

롤링 업데이트 방식으로 주로 사용되는데 SSL 키스토어나 트러스트스토어를 업데이트 하는 것과 같은 작업은 브로커를 재식할 필요 없이 동적 설정 업데이트 기능을 사용해서 할 수 있음 

- 사용중인 클러스터에 새로운 보안 프로토콜을 추가할 때는 브로커에 오래된 프로토콜을 사용하는 기존 리스너는 그대로 두고 새 프로토콜을 사용하는 새로운 리스너를 추가함으로써 업데이트 도중에도 클라이언트 애플리케이션이 오래된 리스너를 사용해서 작동할 수 있다
    1. 카프카 설정 툴을 사용해서 각 브로커에 새로운 포트를 사용하는 새로운 리스너를 추가
    업데이트 명령으로 listeners와 advertised.listeners 설정이 예전 리스너와 새 리스너를 모두 포함하도록 하고, 리스너 이름으로 시작하는 새로운 SASL_SSL 리스너 설정 옵션도 잡아준다
    2. 모든 클라이언트 애플리케이션이 SASL_SSL 리스너를 사용하도록 수정
    3. 만약 브로커 간의 커뮤니케이션이 새로운 SASL_SSL 리스너를 사용하도록 변경되어야 한다면, 새로운 inter.broker.listener.name 설정과 함께 브로커를 롤링 업데이트 함
    4. 설정 툴을 사용해서 에전에 사용하던 리스너를 listeners, advertised.listeners에서 제거하고 예전에 사용하던 리스너 관련해서 더 이상 사용하지 않는 서정이 있다면 삭제

- 이미 사용중인 SASL 리스너에 새로운 SASL 메커니즘을 추가하거나 삭제하는 작업은 클러스터를 정지할 필요 없이 동일 리스너 포트에 대해 롤링 업데이트만 해주면 됨
SASL 메커니즘을 PLAINTEXT→SCRAM-SHA-256 교체 예시
    1. 카프카 설정 툴을 사용해서 모든 사용자를 SCRAM 저장소 추가
    2. sasl.enabled.mechanisms=PLAIN.SCRAM-SHA-256로 설정하고 리스너에 대해서는 listener.name.{리스너-이름}.scram-sha-256.sasl.jaas.config 설정을 잡아주고 브로커를 롤링 업데이트
    3. 모든 클라이언트 애플리케이션이 sasl.mechanism=SCRAM-SHA-256 설정을 사용하도록 수정하고, sasl.jaas.config 설정이 SCRAM을 사용
    4. 만약 리스너가 브로커 간의 커뮤니케이션에 사용된다면 sasl.mechnism.inter.broker.protocol=SCRAM-SHA-256로 잡아주고 브로커를 롤링 업데이트 
    5. PLAIN 메커니즘을 삭제하는 새로운 브로커 롤링 업데이트 수행
    sasl.enabled.mechanisms=SCRAM-SHA-256로 잡아준 뒤 listener.name.{리스너-이름}.plain.sasl.jaas.config 설정과 PLAIN메커니즘에 관련된 다른 설정들을 삭제

## 11.4 암호화

암호화는 데이터의 기밀성과 무결성을 보장하기 위해 사용됨

SSL, SASL_SSL 보안 프로토콜을 사용하는 카프카 리스너는 전송 계층으로 TLS를 사용함으로써 안전하지 않는 네트워크를 통해 전송되는 데이터를 보호하는 안전한 채널을 사용할 수 있게 함 

### 11.4.1 종단 암호화

메시지를 카프카 로그에 저장되는 바이트 배열로 변환하기 위해 시리얼라이저를 사용함

시리얼라이저와 디시리얼라이저는 직렬화 도중에 메시지를 암호화하거나, 역직렬화 도중에 복호화를 수행할 수 있도록 암호화 라이브러리에 통합될 수 있음

1. 카프카 프로듀서를 사용해서 메시지를 보낸다
2. 프로듀서가 KMS에 저장된 암호화 키를 사용해서 메시지를 암호화한다
3. 암호화된 메시지가 브로커로 전달된다. 브로커는 암호화된 메시지를 파티션 로그에 저장한다
4. 브로커가 암호화된 메시지를 컨슈머로 보낸다
5. 컨슈머가 KMS에 저장된 암호화 키를 사용해서 메시지를 복호화한다

프로듀서와 컨슈머에는 KMS로부터 공유 키를 받아올 수 있는 자격 증명이 설정되어야함

## 11.5 인가

사용자가 자원에 대해 어떠한 작동을 수행할 수 있는지를 결정하는 절차

카프카 브로커는 커스터마이즈가 가능한 권한 부여자를 사용해서 접근 제어를 관리함

### 11.5.1 AclAuthorizer

접근 제어 목록(ACL)을 사용해서 카프카 자원에 대한 접근을 세밀하게 제어할 수 있도록 함

- 자원 유형 : Cluster | Topic | Group | TransactionalId | DelegationToken
- 패턴 유형 : Literal | Prefixed
- 자원 이름 : 자원 이름 ,접두어 혹은 와일드 카드
- 작업 : Describe | Create | Delete | Alter | Read | Write | DescribeConfigs | AlterConfigs
- 권한 유형 : Allow | Deny 불허가 허가보다 우선
- 보안 주체 : 카프카의 보안 주체는 <유형>:<이름>의 형태, 모든 권한부여 예시 User:*
- 호스트 : 클라이언트 IP 주소 혹은 와일드 카드

### 11.5.2 인가 기능 커스터마이즈 하기

### 11.5.3 고려 사항

각 사용자 보안 주체에 대해 작업을 수행하는데 꼭 필요한 자원에 대해서만 접근을 허가하고 더 이상 필요가 없어지는 경우 바로 ACL을 제거해야 함

## 11.6 감사

상세한 log4j 로그를 생성하도록 카프카 브로커를 설정할 수 있음

## 11.7 주키퍼 보안

주키퍼는 카프카 클러스터의 가용성을 유지하는데 필수적인 메타데이터를 저장하며, 따라서 카프카뿐만 아니라 주키퍼에도 조치를 취해야함 

### 11.7.1 SASL

java.security.auth.login.config 설정을 잡아주면 됨 

### 11.7.2 SSL

어느 주키퍼 종점에서 켜도 됨

### 11.7.3 인가

주키퍼 경로에 ACL을 설정함으로써 주키퍼 노드에 인가 기능을 설정 할 수 있음 

브로커 설정에 zookeeper.set.acl=true로 잡혀 있으면 브로커는 주키퍼 노드를 설정할 때 노드에 ACL을 설정

메타데이터 노드의 내용을 읽는건 누구나 가능하지만, 쓰는건 브로커만 가능

## 11.8 플랫폼 보안

프로덕션 환경에 대해 보안을 설계할 때는 개별 요소에 가해지는 보안 위협에 대해서뿐만 아니라 전체 시스템에 대한 위협 모델을 고려해야함 

### 11.8.1 비밀번호 보호

## 11.9 요약

- 클라이언트 진정성
- 서버 진정성
- 기밀성
- 무결성
- 접근 제어
- 감사 가능성
- 가용성
