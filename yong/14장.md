# 14장 스트림 처리

## 14.1 스트림 처리란

무한히 늘어나는 데이터세트를 추상화한 것

- 이벤트 스트림에는 순서가 있다 : 이벤트는 그 자체로 다른 이벤트 전에 혹은 후에 발생했다
- 데이터 레코드는 불변하다 : 이벤트는 한 번 발생한 뒤에는 절대로 고칠 수 없다
- 이벤트 스트림은 재생이 가능하다 : 몇 달전, 몇넌 전 발생한 로 스트림을 그대로 재생 가능
- 요청-응답 : 1밀리초 미만 몇 밀리초 수준인 패더다음으로 가장 지연이 적은 패러다임
- 배치 처리 : 지연이 크지만 처리량이 큼
- 스트림 처리 : 연속적이고 논블로킹하게 작동하는 방식

## 14.2 스트림 처리 개념

결국 데이터를 읽고 무엇인가 처리 한뒤 어딘가에 결과물을 쓰는 식의 코드 작성

### 14.2.1 토폴로지

스트림 처리 애플리케이션은 하나 이상의 처리 토폴로지를 포함

하나의 처리 토폴로지 : 하나 이상의 소스 스트림, 스티림 프로세서의 그래프, 하나 이상의 싱크 스트림이 서로 연결된 것으로서 하나 이상의 소스 스트림에서 시작 된 이벤트 스트림은 연결된 스트림 프로세서들을 거쳐가면서 처리되다가 마지막에는 하나 이상의 싱크 스트림에 결과를 쓰는 것으로 끝나게 됨

### 14.2.2 시간

- 이벤트 시간 : 이벤트가 발생하여 레코드가 생성된 시점, 생성 시간과 이벤트 시간을 추가해서 처리 권장
- 로그 추가 시간 : 이벤트가 카프카 브로커에 전달되어 저장된 시점=접수 시간
- 처리 시간 : 연산 수행하기 위해 이벤트를 받은 시간

카프카 스트림즈가 결과물을 카프카 토픽에 쓸 때, 이벤트에 타임프탬프 부여 기준

- 결과 렠드가 입력으로 주어진 레코드에 직접적으로 대응될 경우, 결과 레코드는 입력 레코드와 동일한 타임스탬프 사용
- 결과 레코드가 집계 연산의 결과물일 경우, 집계에 사용된 레코드 타임스탬프의 최대 값을 결과 레코드의 타임스탬프로 사용
- 결과 레코드가 두 스트림을 조인한 결과물일 경우, 조인된 두 레코드 타임스탬프 중 큰 쪽의 타임스탬프를 결과 레코드의 타임스탬프로 사용, 스트림과 테이블을 조인한 경우, 스트림 레코드 쪽의 타임스탬프가 사용
- punctuate()와 같이 입력과 상관업싱 특정한 스케줄에 따라 데이터를 생성하는 카프카 스트림즈 함수에 의해 생성된 결과 레코드의 경우, 타임스탬프 값은 스트림 처리 애플리케이션의 현재 내부 시각에 따라 결정

### 14.2.3 상태

각각의 이벤트 자체만을 살펴보는 것만으로는 충분하지 않고 한 시간 동안 발생한 타입별 이벤트 수나 조인, 합계 및 평균을 계산해야 하는 모든 이벤트 등 더 많은 정보를 추적 관리해야 하고 이를 상태라고 함 

1. 로컬 혹은 내부 상태 : 특정 인스턴스에서만 사용할 수 있는 상태
대게 대플리케이션에 포함되어 있는 내장형 인메모리 데이터베이스를 사용해서 유지 관리함
장점은 엄청나게 빠르다 
단점은 메모리의 제한을 받음
2. 외부 상태 : 카산드라와 같은 외부 nosql 세스템을 이용함
장점 크기에 제한이 없고 다른 애플리케이션에서도 접근 가능
단점 다른 시스템을 추가하는데 지연 증가, 복잡도 증가, 가용성 문제가 발생

### 14.2.4 스트림-테이블 이원성

테이블과는 달리 스트림은 변경 내역을 저장하며 변경 을 유발하는 이벤트의 연속

테이블은 여러 상태 변경의 결과물인 현재 상태를 저장함

### 14.2.5 시간 윈도우

대부분의 스트림 작업은 시간을 윈도우라 불리는 구간 단위로 잘라서 처리함

이동 평균을 계산하거나 이번주 가장 많이 팔린 상품을 계산하거나 시스템의 99분위 부하를 찾아내는 식

- 윈도우 크기 : 5분마다 발생한 모든 이벤트 평균을 구하고 싶은가, 비활동 기간의 길이에 따라 결정되는 세션 윈도우도 지원
- 시간 윈도우의 진행 간격 : 5분 단위 평균은 매분, 매초, 새로운 이벤트가 도착할 때마다 업데이트
- 윈도우를 업데이트할 수 있는 시간 : 업데이트 시간과 평균 시간이 겹치면 특정 시간까지 지연하고 무시

### 14.2.6 처리 보장

카프카는 트랜잭션적이고 멱등적 프로듀서 기능을 사용해서 스트림 처리 애플리케이션에 ‘정확히 한번’ 보장을 지원함

- processing.guarantee 설정 : exactly_once 잡아주면 정확히 한 번 보장 가능

## 14.3 스트림 처리 디자인 패턴

### 14.3.1 단일 이벤트 처리

- 가장 단순한 스트림 처리 패턴
- 각각의 이벤트를 개별적으로 처리
- 맵/필터 패턴으로도 알려졌으며 맵/리듀스 패턴에서 유래

### 14.3.2 로컬 상태와 스트림 처리

- 윈도우 집계와 같이 정보의 집계에 초점을 맞춤
- 집계를 할 때는 상태를 유지할 필요가 있음
- 공유 상태가 아닌 로컬 상태를 사용해서 수행
- 메모리 사용 : 로컬 상태는 애플리케이션 인스턴스가 사용 가능한 메모리 안에 들어갈 수 있는게 이상적
- 영속성 : 인스턴스가 종료되었을 때 상태가 유실되지 않을뿐더러 인스턴스가 재실행되거나 다른 인스턴스에 의해 대체되었을 때 복구될 수 있음을 확신할 수 있어야 함
- 리밸런싱 : 파티션은 이따금 서로 다른 컨슈머에게 다시 할당될 수 있음

### 14.3.3 다단계 처리/리파티셔닝

그룹별 집계가 필요할 때 로컬 상태를 사용하면 좋다

### 14.3.4 외부 검색을 사용하는 처리 : 스트림-테이블 조인

성능과 가용성을 보장하기 위해서는 스트림 처리 애플리케이션 안에 데이터베이스에 저장된 데이터를 캐시 필요

데이터베이스 변경 내역을 이벤트 스트림으로 받아오는 것을 CDC라고 하며 카프카 커넥트는 CDC를 수행하여 데이터 베이스 테이블 변경 이벤트 스트림으로 변환할 수 있는 컨ㄱ터가 여럿 있음

### 14.3.5 테이블-테이블 조인

두 개의 테이블 조인하는 것은 언제나 윈도우 처리되지 않는 연산이며, 작업이 실행되는 시점에서의 양 테이블의 현재 상태를 조인한다

카프카 스트림에서는 동일한 방식으로 파티션된 동이한 키를 가지는 두 개의 테이블에 대해 동등 조인을 수행할 수 있으며, 조인 현산이 많은 수의 애플리케이션 인스턴스와 장비에 효율적으로 분산될 수 있게 함 

### 14.3.6 스트리밍 조인

두 개의 실제 이벤트 스트림을 조인해야 할 경우 

윈도우 조인 : 두 개의 스트림을 조인할 경우 한 쪽 스트림에 포함된  이벤트를 같은 키값과 함께 같은 시간 윈도우에 발생한 다른 쪽 스트림 이벤트와 맞춰야 하기 때문에, 과거와 현재의 이벤트 전체를 조인하게 됨

### 14.3.7 비순차 이벤트

잘못된 시간에 스트림에 도착한 이벤트를 처리하는 경우를 비순차 이벤트라고 하며 사물인터넷에서 많이 발생함

wifi 신호가 끊긴 모바일 장치는 재접속할 때 몇 시간치의 이벤트를 한꺼번에 전송함 

- 이벤트가 순서를 벗어났음을 알아차릴 수 있어야 함, 이를 위해 애플리케이션이 이벤트 시간을 확인해서 현재 시각보다 더 이전인지를 확인할 수 있어야 함
- 비순차 이벤트의 순서를 복구할 수 있는 시간 영역을 정의, 3시간 정도면 복구가 가능하지만, 3주 이상 오래된 것은 포기하는 식
- 순서를 복구하기 위해 이벤트를 묶을 수 있어야 함, 이것은 스트리밍 애플리케이션과 배치 작업의 주요한 차이점, 만약 매일 돌아가는 배치 작업이 있는데 작업이 끝난 후 몇 개의 이벤트가 추가로 도착했다면 보통 어제 작업을 다시 돌려서 이벤트를 변경해준다. 
스트림 처리에서는 이런 개념이 없고 계속해서 돌아가는 동일한 프로세스가 주어진 시점 기준으로 오래 된 이벤트와 새로운 이벤트를 모두 처리해야 함
- 결과를 변경할 수 있어야 함.  스트림 처리의 결과가 데이터베이스에 쓰여질 경우, 결과를 변경하는데 put 혹은 update 정도면 충분하지만 스트림 애플리케이션 결과를 이벨로 전송할 경우 변경이 곤란함

처리 시간과 독립적인 이벤트 시간의 개념을 자체적으로 지원하며, 현재 처리 시간 이전 혹은 이후의 이벤트 시간을 가지는 이벤트를 다룰 수 있는 기능 역시 가지고 있음 

카프카 스트림즈 API는 언제나 집계 결과를 결과 토픽에 쓰고 로그 압착이 설정되어 있으며 키값에 대해 마지막 밸류 값만 유지 됨 

### 14.3.8 재처리하기

이벤트를 재처리하는 것으로 두 가지 변형이 있음

- 새로 개선된 버전의 스트림 처리 애플리케이션으로 구 버전에서 사용하던 그 이벤트 스트림을 신 버전 애플리케이션에서 읽어와서 산출된 새로운 결과 스트림을 쓴다.
→ 이벤트 스트림을 오랫동안 온전히 저장하기에 쉽게 해결 가능함
    1. 신버전 애플리케이션을 새 컨슈머 그룹으로 실행
    2. 신버전 애플리케이션이 입력 토픽의 첫 번쨰 오프셋부터 처리를 시작하도록 설정해서 입력 스트림의 모든 이벤트에 대한 복사본을 가질수 있도록 함 
    3. 신버전 애플리케이션이 처리를 계속하도록 하고, 신버전 처리 작업이 따라 잡았을 때 클라이언트 애플리케이션을 새로운 결과 스트림으로 전환함
- 기존의 스트림 처리 애플리케이션에 버그가 많으니 버그를 고친 뒤 이벤트스트림을 재처리해서 결과를 다시 산출하고자 한다
→ 이미 존재하는 애플리케이션을 초기화해서 입력 스트림의 맨 처음부터 다시 처리하도록 되돌리고 , ㄹ컬 상태를 초기화하고, 아마도 기존 출력 스트림 내용물 역시 지워야 할 수 있음
되도록이면 첫번쨰 방식을 권장

### 14.3.9 인터랙티브 쿼리

## 14.4 예제로 보는 카프카 스트림즈

아파치 카프카는 2개의 스트림 API wprhd

- 저수준의 Processor API
- 고수준의 스트림즈 DSL

### 14.4.1 단어 개수 세기

### 14.4.2 주식 시장 통계

### 14.4.3 클릭 스트림 확장

## 14.5 카프카 스트림즈 : 아키텍처 개요

### 14.5.1 토폴로지 생성

### 14.5.2 토폴로지 최적화

### 14.5.3 토폴로지 테스트

### 14.5.4 토폴로지 규모 확장

### 14.5.5 장애 처리

## 14.6 스트림 처리 활용 사례

1. 고객 서비스 
2. 사물 인테넛
3. 사기 탐지

## 14.7 스트림 처리 프레임워크 선택

- 데이터 수집
- 밀리초 단위 작업
- 비동기 마이크로 서비스
- 준 실시간 데이터 분석
- 시스템 운용성
- 사용 및 디버깅 용이성
- 어려운 일을 쉽게 해줌
- 커뮤니티
